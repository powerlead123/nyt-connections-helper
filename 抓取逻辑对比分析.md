# 抓取逻辑对比分析 📊

## 概述

我们的系统有三个不同的数据获取端点，每个都有不同的抓取策略：

## 1. **today.js** - 纯缓存读取 📦

### 特点
- **不进行任何抓取**
- 只从KV存储读取数据
- 用户访问的主要端点

### 逻辑流程
```
用户请求 → 检查KV存储 → 返回缓存数据 OR 返回"数据未准备好"
```

### 代码特点
```javascript
// 严格从KV存储读取，不允许用户触发Mashable抓取
const cachedPuzzle = await env.CONNECTIONS_KV.get(`puzzle-${today}`, 'json');
if (cachedPuzzle) {
    return cachedPuzzle; // 直接返回
}
// 没有数据时返回错误，不会尝试抓取
```

---

## 2. **scheduled.js** - 定时自动抓取 ⏰

### 特点
- **GitHub Actions定时触发**
- 复杂的多URL、多代理策略
- 自动保存到KV存储

### 逻辑流程
```
定时触发 → 多URL尝试 → 多代理服务 → 解析数据 → 保存到KV → 生成文章
```

### 抓取策略
```javascript
// 多个URL格式
const urls = [
    `https://mashable.com/article/nyt-connections-hint-answer-today-${monthName}-${dayNum}-${year}`,
    `https://mashable.com/article/nyt-connections-answer-today-${monthName}-${dayNum}-${year}`,
    `https://mashable.com/article/connections-hint-answer-today-${monthName}-${dayNum}-${year}`
];

// 多个代理服务
const proxyServices = [
    (url) => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
    (url) => `https://cors-anywhere.herokuapp.com/${url}`,
    (url) => url // 直接访问
];
```

### 解析方法
- 日期验证
- 颜色提示匹配
- 多种单词提取模式
- 复杂的HTML解析

---

## 3. **refresh.js** - 管理员手动抓取 🔧

### 特点
- **管理员手动触发**
- 简化的抓取逻辑
- 专门的强制刷新解析

### 逻辑流程
```
管理员点击 → 强制抓取 → 专用解析器 → 保存到KV → 返回结果
```

### 抓取策略（简化版）
```javascript
// 单一URL格式
const targetUrl = `https://mashable.com/article/nyt-connections-hint-answer-today-${monthName}-${day}-${year}`;

// 精选代理服务（去掉不稳定的）
const proxyServices = [
    (url) => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
    (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`
];
```

### 专用解析器
```javascript
function parseForceRefresh(html, dateStr) {
    // 1. 查找颜色提示
    // 2. 使用专门的extractConnectionsWords()
    // 3. 多种备用解析策略
    // 4. 返回结构化数据
}
```

---

## 核心区别对比 🔍

| 特性 | today.js | scheduled.js | refresh.js |
|------|----------|--------------|------------|
| **触发方式** | 用户请求 | 定时自动 | 管理员手动 |
| **是否抓取** | ❌ 不抓取 | ✅ 自动抓取 | ✅ 强制抓取 |
| **数据来源** | KV缓存 | Mashable实时 | Mashable实时 |
| **URL数量** | 0 | 3个备用 | 1个主要 |
| **代理数量** | 0 | 3个 | 2个精选 |
| **解析复杂度** | 无 | 高复杂度 | 中等复杂度 |
| **错误处理** | 返回提示 | 多重备用 | 返回现有数据 |
| **超时设置** | 无 | 15秒 | 20秒 |

---

## 解析逻辑对比 🧩

### scheduled.js 解析特点
- **日期验证**: 确认是今天的文章
- **多模式匹配**: 支持各种HTML格式
- **复杂备用**: 多层备用解析策略
- **严格验证**: 确保数据完整性

### refresh.js 解析特点  
- **专用函数**: `parseForceRefresh()` 专门处理手动刷新
- **智能提取**: `extractConnectionsWords()` 基于Mashable格式
- **结构化优先**: 优先使用分组数据而非单词数组
- **快速备用**: 简化的备用策略

---

## 使用场景 📅

### today.js
- **用户日常访问**
- **高频请求**
- **稳定性优先**

### scheduled.js  
- **每日自动更新**
- **无人值守运行**
- **可靠性优先**

### refresh.js
- **数据更新失败时**
- **管理员干预**
- **即时性优先**

---

## 总结 📝

**refresh.js的抓取逻辑**是scheduled.js的**简化专用版本**：

1. **更少的URL尝试** - 只用最可能成功的URL
2. **精选代理服务** - 去掉不稳定的代理
3. **专门的解析器** - 针对手动刷新优化
4. **更好的错误处理** - 失败时返回现有数据
5. **适中的超时** - 平衡速度和成功率

这样设计的好处是：
- ✅ 管理员操作响应更快
- ✅ 减少不必要的网络请求
- ✅ 专门优化的解析逻辑
- ✅ 更好的用户体验

**不是完全相同的逻辑，而是针对手动操作场景的优化版本！** 🎯