# 定时抓取解析逻辑详解 🧩

## 解析流程概览 📋

定时抓取的解析逻辑位于 `functions/scheduled.js` 中的 `parseMashableHTML()` 函数，采用**多层级、多策略**的解析方法：

```
HTML输入 → 日期验证 → 颜色提示提取 → 单词提取 → 分组创建 → 数据输出
```

---

## 1. 日期验证阶段 📅

### 目的
确认抓取的是今天的文章，避免解析错误日期的内容

### 实现逻辑
```javascript
// 构建日期匹配模式
const today = new Date();
const monthName = ['january', 'february', ...][today.getMonth()];
const day = today.getDate();

const datePatterns = [
    new RegExp(`${monthName}\\s+${day}`, 'i'),     // "september 9"
    new RegExp(`${day}\\s+${monthName}`, 'i'),     // "9 september"  
    new RegExp(`${today.getMonth() + 1}[\/\\-]${day}`, 'i'), // "9/9" or "9-9"
    new RegExp(`${day}[\/\\-]${today.getMonth() + 1}`, 'i')  // "9/9" or "9-9"
];

// 验证HTML中是否包含今天日期
let hasDateMatch = false;
for (const pattern of datePatterns) {
    if (pattern.test(html)) {
        hasDateMatch = true;
        break;
    }
}
```

### 结果处理
- ✅ **找到日期匹配**: 继续解析
- ⚠️ **未找到日期**: 记录警告但继续解析（可能是格式变化）

---

## 2. 颜色提示提取阶段 🌈

### 目的
提取Yellow、Green、Blue、Purple四个分组的主题提示

### 主要模式
```javascript
// 改进的颜色提示模式
const improvedAnswerPattern = /(Yellow|Green|Blue|Purple)[\s\S]*?<strong[^>]*>([^<]+)<\/strong>/gi;
const colorMatches = [...html.matchAll(improvedAnswerPattern)];
```

### 提取逻辑
```javascript
const hints = {};
colorMatches.forEach(match => {
    const color = match[1];      // Yellow/Green/Blue/Purple
    const hint = match[2].trim(); // 提示文本
    hints[color] = hint;
});
```

### 示例结果
```javascript
hints = {
    Yellow: "Piquancy",
    Green: "Without a romantic partner", 
    Blue: "Male animals",
    Purple: "Chinese dynasties"
}
```

---

## 3. 单词提取阶段 🔤

### 策略1: 答案区域定向提取
```javascript
// 查找包含答案的HTML区域
const answerSectionPattern = /(?:answer|solution)[\s\S]{0,2000}/gi;
const answerSections = html.match(answerSectionPattern) || [];

// 在答案区域中查找单词
const wordListPatterns = [
    // 逗号分隔的大写单词组
    /([A-Z][A-Z\-\d]*),\s*([A-Z][A-Z\-\d]*),\s*([A-Z][A-Z\-\d]*),\s*([A-Z][A-Z\-\d]*)/g,
    // HTML列表项
    /<li[^>]*>([A-Z][A-Z\-\d\s]*)<\/li>/gi,
    // 强调标签中的单词
    /<(?:strong|b)[^>]*>([A-Z][A-Z\-\d\s]*)<\/(?:strong|b)>/gi
];
```

### 策略2: 特定答案格式匹配
```javascript
// 查找完整的颜色+提示格式
const answerPattern = /Yellow:\s*<strong>([^<]+)<\/strong>[\s\S]*?Green:\s*<strong>([^<]+)<\/strong>[\s\S]*?Blue:[\s\S]*?<strong>([^<]+)<\/strong>[\s\S]*?Purple:[\s\S]*?<strong>([^<]+)<\/strong>/i;
```

### 策略3: 通用解析方法
```javascript
// 多种通用模式
const answerPatterns = [
    /(?:Green|Yellow|Blue|Purple)[\s\S]*?:([\s\S]*?)(?=(?:Green|Yellow|Blue|Purple)|$)/gi,
    /(?:🟢|🟡|🔵|🟣)[\s\S]*?:([\s\S]*?)(?=(?:🟢|🟡|🔵|🟣)|$)/gi,
    /<strong[^>]*>(?:Green|Yellow|Blue|Purple)[^<]*<\/strong>([\s\S]*?)(?=<strong[^>]*>(?:Green|Yellow|Blue|Purple)|$)/gi
];
```

### 策略4: 列表格式解析
```javascript
// HTML列表项解析
const listPattern = /<li[^>]*>(.*?)<\/li>/gi;
const listItems = [...html.matchAll(listPattern)];

// 每4个列表项组成一个分组
for (let i = 0; i < 4; i++) {
    const groupWords = [];
    for (let j = 0; j < 4; j++) {
        const itemIndex = i * 4 + j;
        if (itemIndex < listItems.length) {
            const word = extractWordsFromText(listItems[itemIndex][1])[0];
            if (word) groupWords.push(word);
        }
    }
}
```

---

## 4. 单词清理和过滤 🧹

### extractWordsFromText函数
```javascript
function extractWordsFromText(text) {
    // 移除HTML标签
    const cleanText = text.replace(/<[^>]*>/g, ' ');
    
    // 多种单词模式
    const wordPatterns = [
        /\b[A-Z][A-Z\s\-']+\b/g,  // 全大写单词
        /\b[A-Z][a-z]+\b/g,       // 首字母大写
        /\b[A-Z]+\b/g             // 纯大写
    ];
    
    // 清理和去重
    const cleanWords = allWords
        .map(word => word.trim().toUpperCase())
        .filter(word => word.length >= 2 && word.length <= 15)
        .filter((word, index, arr) => arr.indexOf(word) === index);
    
    return cleanWords;
}
```

### 排除词汇过滤
```javascript
const excludeWords = [
    'MASHABLE', 'CONNECTIONS', 'WORDLE', 'NYT', 'TIMES', 'PUZZLE', 'GAME',
    'ANSWER', 'HINT', 'TODAY', 'DAILY', 'SOLUTION', 'CATEGORY', 'CATEGORIES',
    'HTML', 'CSS', 'JAVASCRIPT', 'ARTICLE', 'CONTENT', 'PAGE', 'WEBSITE',
    'SEARCH', 'RESULT', 'TECH', 'SCIENCE', 'NEWS', 'SOCIAL', 'MEDIA',
    'SUBSCRIBE', 'NEWSLETTER', 'EMAIL', 'FOLLOW', 'SHARE', 'LIKE',
    // 月份名称
    'JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE',
    'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'
];
```

---

## 5. 分组创建逻辑 🎯

### 数据结构
```javascript
const groups = [
    {
        theme: "分组主题",                    // 从颜色提示中提取
        words: ["WORD1", "WORD2", "WORD3", "WORD4"], // 4个单词
        difficulty: "yellow|green|blue|purple",      // 难度颜色
        hint: "提示信息"                     // 解释文本
    }
];
```

### 分组策略
1. **基于颜色提示**: 如果成功提取到4个颜色的提示，按颜色分组
2. **基于位置**: 按单词在HTML中的出现顺序分组
3. **均匀分配**: 将找到的单词平均分成4组

### 难度映射
```javascript
const difficultyMap = {
    0: 'green',   // 最简单
    1: 'yellow',  // 简单
    2: 'blue',    // 困难  
    3: 'purple'   // 最困难
};
```

---

## 6. 备用解析策略 🔄

### 层级备用机制
```
主策略失败 → 备用策略1 → 备用策略2 → 备用策略3 → 通用提取
```

### 各策略特点
1. **主策略**: 基于颜色提示的精确匹配
2. **备用策略1**: 通用颜色模式匹配
3. **备用策略2**: HTML列表项解析
4. **备用策略3**: 全文单词提取
5. **最终备用**: 返回硬编码的备用数据

---

## 7. 输出数据格式 📤

### 成功解析输出
```javascript
{
    date: "2025-09-09",
    words: ["KICK","PUNCH","ZEST","ZING", ...], // 16个单词
    groups: [
        {
            theme: "Piquancy",
            words: ["KICK","PUNCH","ZEST","ZING"],
            difficulty: "yellow",
            hint: "Piquancy"
        },
        // ... 其他3个分组
    ],
    source: "Mashable (Improved)" // 标识数据来源
}
```

### 失败处理
- 返回 `null`
- 触发备用数据源
- 最终使用硬编码备用数据

---

## 8. 解析逻辑的优势 ✅

### 多重保障
- **4种主要策略** + **多个备用方案**
- **智能单词过滤** 排除网站相关词汇
- **日期验证** 确保数据准确性
- **容错机制** 适应网站格式变化

### 适应性强
- 支持多种HTML格式
- 兼容不同的单词表示方式
- 处理各种边界情况

### 可维护性
- 模块化函数设计
- 详细的日志记录
- 清晰的错误处理

---

## 9. 潜在问题和改进 ⚠️

### 已知问题
1. **createGroupsFromWords函数未定义** - 代码中调用但未实现
2. **硬编码模式依赖** - 部分解析依赖特定HTML格式
3. **单词顺序假设** - 假设单词按分组顺序出现

### 改进建议
1. **实现缺失函数** - 补充createGroupsFromWords实现
2. **增强模式匹配** - 添加更多HTML格式支持
3. **智能分组** - 基于语义而非位置进行分组
4. **机器学习** - 使用AI模型提高解析准确性

---

## 总结 📝

定时抓取的解析逻辑是一个**复杂而强大**的系统：

🎯 **多策略并行**: 4种主要解析策略 + 多个备用方案
🧹 **智能过滤**: 自动排除无关词汇，提取有效单词
🔄 **容错机制**: 层层备用，确保系统稳定运行
📊 **结构化输出**: 标准化的数据格式，便于后续处理

这套解析逻辑确保了即使在Mashable网站格式发生变化的情况下，系统仍能稳定地提取NYT Connections的谜题数据！ 🚀