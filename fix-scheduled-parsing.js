// 修复scheduled.js的解析逻辑 - 基于之前成功的方法\nasync function fixScheduledParsing() {\n    console.log('🔧 修复scheduled.js的解析逻辑');\n    console.log('基于之前成功的解析流程');\n    console.log('=' .repeat(50));\n    \n    try {\n        const today = new Date();\n        const dateStr = today.toISOString().split('T')[0];\n        const monthNames = ['january', 'february', 'march', 'april', 'may', 'june',\n                           'july', 'august', 'september', 'october', 'november', 'december'];\n        const monthName = monthNames[today.getMonth()];\n        const day = today.getDate();\n        const year = today.getFullYear();\n        \n        // 1. 构造类似的Mashable URL\n        const url = `https://mashable.com/article/nyt-connections-hint-answer-today-${monthName}-${day}-${year}`;\n        console.log('🌐 目标URL:', url);\n        \n        // 获取HTML内容\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            signal: AbortSignal.timeout(15000)\n        });\n        \n        const html = await response.text();\n        console.log(`✅ 获取HTML: ${html.length} 字符`);\n        \n        // 使用成功的解析逻辑\n        const result = parseWithSuccessfulMethod(html, dateStr);\n        \n        if (result && result.groups && result.groups.length === 4) {\n            console.log('🎉 成功解析!');\n            console.log('\\n📊 解析结果:');\n            console.log('日期:', result.date);\n            console.log('数据源:', result.source);\n            console.log('单词数量:', result.words.length);\n            console.log('分组数量:', result.groups.length);\n            \n            console.log('\\n🎯 今天的正确答案:');\n            result.groups.forEach((group, i) => {\n                const emoji = {\n                    'yellow': '🟡',\n                    'green': '🟢',\n                    'blue': '🔵',\n                    'purple': '🟣'\n                }[group.difficulty] || '⚪';\n                \n                console.log(`  ${emoji} ${group.theme}`);\n                console.log(`     ${group.words.join(', ')}`);\n            });\n            \n            return result;\n            \n        } else {\n            console.log('❌ 解析失败');\n            return null;\n        }\n        \n    } catch (error) {\n        console.error('❌ 修复测试失败:', error);\n        return null;\n    }\n}\n\n// 基于成功方法的解析函数\nfunction parseWithSuccessfulMethod(html, dateStr) {\n    try {\n        console.log('\\n🔍 步骤1: 查找提示区域...');\n        \n        // 2. 查找提示区域：Today's connections fall into the following categories:\n        const hintSectionPattern = /Today's connections fall into the following categories:([\\s\\S]*?)(?=What is the answer to Connections today|$)/i;\n        const hintSectionMatch = html.match(hintSectionPattern);\n        \n        if (!hintSectionMatch) {\n            console.log('❌ 未找到提示区域');\n            return null;\n        }\n        \n        const hintSection = hintSectionMatch[1];\n        console.log('✅ 找到提示区域');\n        console.log('提示区域内容 (前200字符):', hintSection.substring(0, 200));\n        \n        // 3. 提取4个分组名称（Yellow, Green, Blue, Purple）\n        console.log('\\n🔍 步骤2: 提取分组名称...');\n        \n        const colorHints = {};\n        const colorPatterns = [\n            /Yellow[^:]*:([^\\n]*)/i,\n            /Green[^:]*:([^\\n]*)/i,\n            /Blue[^:]*:([^\\n]*)/i,\n            /Purple[^:]*:([^\\n]*)/i\n        ];\n        \n        const colors = ['Yellow', 'Green', 'Blue', 'Purple'];\n        \n        colors.forEach((color, i) => {\n            const match = hintSection.match(colorPatterns[i]);\n            if (match) {\n                const hint = match[1].trim().replace(/<[^>]*>/g, '').replace(/[\"']/g, '');\n                colorHints[color] = hint;\n                console.log(`  ${color}: ${hint}`);\n            }\n        });\n        \n        if (Object.keys(colorHints).length < 4) {\n            console.log('❌ 未找到足够的分组提示');\n            return null;\n        }\n        \n        // 4. 查找答案区域：从What is the answer to Connections today到Don't feel down...\n        console.log('\\n🔍 步骤3: 查找答案区域...');\n        \n        const answerSectionPattern = /What is the answer to Connections today([\\s\\S]*?)Don't feel down/i;\n        const answerSectionMatch = html.match(answerSectionPattern);\n        \n        if (!answerSectionMatch) {\n            console.log('❌ 未找到答案区域');\n            return null;\n        }\n        \n        const answerSection = answerSectionMatch[1];\n        console.log('✅ 找到答案区域');\n        console.log('答案区域内容 (前300字符):', answerSection.substring(0, 300));\n        \n        // 5. 基于分组名称解析每组的4个单词\n        console.log('\\n🔍 步骤4: 解析每组的4个单词...');\n        \n        const groups = [];\n        const difficulties = ['yellow', 'green', 'blue', 'purple'];\n        \n        // 方法A: 查找冒号分隔的格式\n        for (let i = 0; i < colors.length; i++) {\n            const color = colors[i];\n            const difficulty = difficulties[i];\n            const hint = colorHints[color];\n            \n            // 在答案区域查找这个颜色的单词\n            const colorWordPatterns = [\n                // 格式1: Yellow: WORD1, WORD2, WORD3, WORD4\n                new RegExp(`${color}[^:]*:([^\\n]*?)(?=${colors.join('|')}|$)`, 'i'),\n                // 格式2: 查找提示后的单词\n                new RegExp(`${hint.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}[^:]*:?([^\\n]*?)(?=${colors.join('|')}|$)`, 'i')\n            ];\n            \n            let words = [];\n            \n            for (const pattern of colorWordPatterns) {\n                const match = answerSection.match(pattern);\n                if (match) {\n                    const wordsText = match[1].trim();\n                    console.log(`  ${color} 原始文本: \"${wordsText}\"`);\n                    \n                    // 提取单词\n                    words = extractWordsFromAnswerText(wordsText);\n                    if (words.length >= 4) {\n                        console.log(`  ${color} 提取单词: ${words.slice(0, 4).join(', ')}`);\n                        break;\n                    }\n                }\n            }\n            \n            if (words.length >= 4) {\n                groups.push({\n                    theme: hint,\n                    words: words.slice(0, 4),\n                    difficulty: difficulty,\n                    hint: hint\n                });\n            } else {\n                console.log(`  ❌ ${color} 未找到足够的单词 (找到 ${words.length} 个)`);\n            }\n        }\n        \n        // 方法B: 如果方法A失败，尝试查找所有大写单词并按顺序分组\n        if (groups.length < 4) {\n            console.log('\\n🔄 尝试备用方法: 按顺序分组所有单词...');\n            \n            const allWords = extractAllWordsFromAnswerSection(answerSection);\n            console.log(`找到 ${allWords.length} 个候选单词:`, allWords.slice(0, 20).join(', '));\n            \n            if (allWords.length >= 16) {\n                groups.length = 0; // 清空之前的结果\n                \n                for (let i = 0; i < 4; i++) {\n                    const color = colors[i];\n                    const difficulty = difficulties[i];\n                    const hint = colorHints[color];\n                    const words = allWords.slice(i * 4, (i + 1) * 4);\n                    \n                    groups.push({\n                        theme: hint,\n                        words: words,\n                        difficulty: difficulty,\n                        hint: hint\n                    });\n                }\n                \n                console.log('✅ 使用备用方法成功分组');\n            }\n        }\n        \n        if (groups.length === 4) {\n            console.log('\\n🎉 成功解析4个分组!');\n            return {\n                date: dateStr,\n                words: groups.flatMap(g => g.words),\n                groups: groups,\n                source: 'Mashable (Successful Method)'\n            };\n        } else {\n            console.log(`\\n❌ 只解析出 ${groups.length} 个分组，需要4个`);\n            return null;\n        }\n        \n    } catch (error) {\n        console.error('解析错误:', error);\n        return null;\n    }\n}\n\n// 从答案文本中提取单词\nfunction extractWordsFromAnswerText(text) {\n    if (!text) return [];\n    \n    // 清理HTML标签\n    const cleanText = text.replace(/<[^>]*>/g, ' ');\n    \n    // 多种单词提取模式\n    const patterns = [\n        // 逗号分隔的单词\n        /([A-Z][A-Z0-9\\-']*),\\s*([A-Z][A-Z0-9\\-']*),\\s*([A-Z][A-Z0-9\\-']*),\\s*([A-Z][A-Z0-9\\-']*)/g,\n        // 空格分隔的大写单词\n        /\\b[A-Z][A-Z0-9\\-']*\\b/g\n    ];\n    \n    let words = [];\n    \n    // 尝试逗号分隔格式\n    const commaMatch = cleanText.match(patterns[0]);\n    if (commaMatch) {\n        const match = commaMatch[0].match(/[A-Z][A-Z0-9\\-']*/g);\n        if (match && match.length >= 4) {\n            words = match.slice(0, 4);\n        }\n    }\n    \n    // 如果逗号分隔失败，尝试提取所有大写单词\n    if (words.length < 4) {\n        const allMatches = cleanText.match(patterns[1]) || [];\n        words = allMatches\n            .filter(word => word.length >= 2 && word.length <= 15)\n            .filter(word => !/^(THE|AND|OR|OF|TO|IN|FOR|WITH|ON|AT|BY|FROM)$/.test(word))\n            .slice(0, 4);\n    }\n    \n    return words.map(word => word.trim().toUpperCase());\n}\n\n// 从答案区域提取所有单词\nfunction extractAllWordsFromAnswerSection(text) {\n    const cleanText = text.replace(/<[^>]*>/g, ' ');\n    \n    const words = cleanText.match(/\\b[A-Z][A-Z0-9\\-']*\\b/g) || [];\n    \n    return words\n        .filter(word => word.length >= 2 && word.length <= 15)\n        .filter(word => {\n            const excludeWords = [\n                'THE', 'AND', 'OR', 'OF', 'TO', 'IN', 'FOR', 'WITH', 'ON', 'AT', 'BY', 'FROM',\n                'YELLOW', 'GREEN', 'BLUE', 'PURPLE', 'CONNECTIONS', 'ANSWER', 'TODAY'\n            ];\n            return !excludeWords.includes(word);\n        })\n        .filter((word, index, arr) => arr.indexOf(word) === index) // 去重\n        .slice(0, 20);\n}\n\n// 运行修复测试\nconsole.log('🚀 启动scheduled.js解析逻辑修复测试...\\n');\nfixScheduledParsing().then(result => {\n    console.log('\\n' + '='.repeat(50));\n    if (result) {\n        console.log('🎉 修复成功!');\n        console.log('✅ 基于成功方法的解析逻辑工作正常');\n        console.log('📊 可以用这个逻辑更新scheduled.js和refresh.js');\n    } else {\n        console.log('❌ 修复失败');\n        console.log('🔍 需要进一步调试或调整解析逻辑');\n    }\n    console.log('测试结束:', new Date().toLocaleString());\n});"